

## [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

==双指针==，==2023年12月1日== 



给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：**你不能倾斜容器。

**提示：**

- `n == height.length`
- `2 <= n <= 105`
- `0 <= height[i] <= 104`



**示例一** 

![img](https://gcore.jsdelivr.net/gh/lzcgeorge/imagebed@main/question_11.jpg)

```bash
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

### 思路

在每个状态下，无论长板或短板向中间收窄一格，都会导致水槽 **底边宽度** $−1$ 变短：

- 若向内 移动短板 ，水槽的短板 $min(h[i],h[j])$ 可能变大，因此下个水槽的面积 可能增大 。
- 若向内 移动长板 ，水槽的短板 $min(h[i],h[j])$ 不变或变小，因此下个水槽的面积 一定变小 。

因此，初始化双指针分列水槽左右两端，循环每轮将短板向内移动一格，并更新面积最大值，直到两指针相遇时跳出；即可获得最大面积。

```c++
class Solution {
public:
    int maxArea(vector<int>& h) {
        int l = 0,r = h.size() - 1;
        int mx = (r - l) * min(h[l],h[r]);

        while(l < r) {
            if(h[l] < h[r]) 
                l ++;
            else r --;
            mx = max(mx,(r - l) * min(h[l],h[r]));
        }
        return mx;
    }
};
```

## [2661. 找出叠涂元素](https://leetcode.cn/problems/first-completely-painted-row-or-column/)

==hash== ==2023年12月1日==

给你一个下标从 **0** 开始的整数数组 `arr` 和一个 `m x n` 的整数 **矩阵** `mat` 。`arr` 和 `mat` 都包含范围 `[1，m * n]` 内的 **所有** 整数。

从下标 `0` 开始遍历 `arr` 中的每个下标 `i` ，并将包含整数 `arr[i]` 的 `mat` 单元格涂色。

请你找出 `arr` 中在 `mat` 的某一行或某一列上都被涂色且下标最小的元素，并返回其下标 `i` 。



**示例 1：**

![image explanation for example 1](https://gcore.jsdelivr.net/gh/lzcgeorge/imagebed@main/grid1.jpg)

```bash
输入：arr = [1,3,4,2], mat = [[1,4],[2,3]]
输出：2
解释：遍历如上图所示，arr[2] 在矩阵中的第一行或第二列上都被涂色。
```

### 思路

​    1. 记录 `mat` 矩阵中每一个数的行和列

​    2. 扫描 `arr` 数组，每进来一个数，当前的行和列分别加一

​    3. 当前行/列 满的时候退出

​    4. 时间复杂度：$O(n*m) + O(n*m) = O(n*m)$

 ```c++
 class Solution {
 public:
     int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {
         map<int,pair<int,int>> mp;
         int n = mat.size(), m = mat[0].size();
         vector<int> row(n,0),col(m,0);
         for(int i = 0; i < n; i ++)
             for(int j = 0; j < m; j ++) {
                 mp[mat[i][j]] = {i,j};
             }
         
         for(int i = 0; i < n*m; i ++) {
             auto [x,y] = mp[arr[i]];
             row[x] ++, col[y] ++;
             // 注意：某一行有多少个数 = 列的个数
             if(row[x] == m || col[y] == n) {
                 return i;
             }
         }
 
         return -1; // 实际走不到这里
     }
 };
 ```

## [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

==模拟== ==2023年12月2日==

给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。

请 **不要使用除法，**且在 `O(n)` 时间复杂度内完成此题。

**示例 1:**

```bash
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**提示：**

- `2 <= nums.length <= 105`
- `-30 <= nums[i] <= 30`
- **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内



### 思路

```bash
/*
原数组：       [1       2       3       4]
左部分的乘积：   1       1      1*2    1*2*3
右部分的乘积： 2*3*4    3*4      4      1
结果：        1*2*3*4  1*3*4   1*2*4  1*2*3*1

*/
```



```c++

class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> left(n,1),right(n,1);
        // 前缀
        for(int i = 1; i < n; i ++)
            left[i] = nums[i - 1] * left[i - 1];
        // 后缀
        for(int j = n-2; j >= 0; j -- )
            right[j] = nums[j + 1] * right[j + 1];
        // 合并 
        for(int i = 0; i < n; i ++)
            right[i] = left[i] * right[i];
        return right;
            
    }
};
```

## [1094. 拼车](https://leetcode.cn/problems/car-pooling/)

==差分数组== ==2023年12月2日==

车上最初有 `capacity` 个空座位。车 **只能** 向一个方向行驶（也就是说，**不允许掉头或改变方向**）

给定整数 `capacity` 和一个数组 `trips` ,  `trip[i] = [numPassengersi, fromi, toi]` 表示第 `i` 次旅行有 `numPassengersi` 乘客，接他们和放他们的位置分别是 `fromi` 和 `toi` 。这些位置是从汽车的初始位置向东的公里数。

当且仅当你可以在所有给定的行程中接送所有乘客时，返回 `true`，否则请返回 `false`。



**示例 1：**

```bash
输入：trips = [[2,1,5],[3,3,7]], capacity = 4
输出：false
```



**提示：**

- `1 <= trips.length <= 1000`
- `trips[i].length == 3`
- `1 <= numPassengersi <= 100`
- `0 <= fromi < toi <= 1000`
- `1 <= capacity <= 105`



### 思路

1. 保证，每一站上都是 people  < capacity
2. 处理差分数组，然后还原数组，某个点上的最大人数
3. 一些细节：为了方便，人为规定站点编号从 1 开始。

```c++
class Solution {
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        // 其实用不到排序
        /*
            auto cmp = [](auto a,auto b) {
                if(a[1] == b[1] ) return a[2] < b[2];
                return a[1] < b[1];
            };
            sort(trips.begin(),trips.end(),cmp);
		*/
        
        int n = trips.size();
        vector<int> peo(1002,0);
        for(auto c: trips) {
            int from = c[1],to = c[2];
            int num = c[0];
            peo[from + 1] += num;
            peo[to + 1] -= num;
        }
        for(int i = 1; i <= 1001; i ++) {
            peo[i] += peo[i-1];
            if(peo[i] > capacity) return false;
        }
        return true;
    }
};
```



## [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

==模拟== ==滑动窗口== ==2023年12月2日== 

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。



**示例 1：**

```bash
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```



**提示：**

- `1 <= target <= 109`
- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 105`

 

### 思路

第一版代码:

先判断是否有解

有解的话，先找出一个满足条件的解，然后 滑动窗口 （开滑！）

```c++
using ll = long long;
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        ll sum = 0;
        for(auto c: nums) sum += c;
        if(sum < target) return 0;
        ll t = 0;
        int l = 0,r = 0;
        while(t + nums[r] < target) t += nums[r ++];
        int res = r - l + 1;
        while(r < nums.size()) {
            // cout << l << " " << r <<"\n";
            t += nums[r++];
            while(t >= target) t -= nums[l ++];
            res = min(res, r - l + 1);
        }        
        return res;
    }
};
```



第二版代码：

直接滑，满足条件的记录值

```c++
using ll = long long;
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        ll sum = 0;
        int l = 0,r = 0, res = nums.size() + 1;
        while(r < nums.size()) {
            sum += nums[r++];
            while(sum >= target) {
                sum -= nums[l ++];
                res = min(res, r - l + 1);
            }
            
        }        
        return res > nums.size() ? 0 : res;
    }
};
```

## [1423. 可获得的最大点数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/)

==模拟== ==滑动窗口== ==2023年12月3日== 

几张卡牌 **排成一行**，每张卡牌都有一个对应的点数。点数由整数数组 `cardPoints` 给出。

每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 `k` 张卡牌。

你的点数就是你拿到手中的所有卡牌的点数之和。

给你一个整数数组 `cardPoints` 和整数 `k`，请你返回可以获得的最大点数。

 

**示例 1：**

```bash
输入：cardPoints = [1,2,3,4,5,6,1], k = 3
输出：12
解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。
```



**提示：**

- `1 <= cardPoints.length <= 10^5`
- `1 <= cardPoints[i] <= 10^4`
- `1 <= k <= cardPoints.length`



### 思路

1. 最后的结果：前面 a 个，后面 b 个，a + b = k
2. 前假设都在前面选，得到一个 `cur` 结果
3. 然后逐次递减在前面选的，从后面选



```c++
class Solution {
public:
    int maxScore(vector<int>& a, int k) {
        // 最后的结果：前面 a 个，后面 b 个，a + b = k
        int n = a.size();
        int mx = -1,cur = 0;
        for(int i = 0; i < k; i ++) cur += a[i];
        mx = cur;

        // 滑动窗口
        for(int l = k-1,r = n - 1; l >= 0; l --,r --) {
            cur = cur - a[l] + a[r];
            mx = max(mx,cur);
        }
        return mx;
    }
};
```

## [1038. 从二叉搜索树到更大和树](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/)

给定一个二叉搜索树 `root` (BST)，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。

提醒一下， *二叉搜索树* 满足下列约束条件：

- 节点的左子树仅包含键 **小于** 节点键的节点。
- 节点的右子树仅包含键 **大于** 节点键的节点。
- 左右子树也必须是二叉搜索树。

 

**示例 1：**

**![img](https://gcore.jsdelivr.net/gh/lzcgeorge/imagebed@main/tree.png)**

```bash
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```



**提示：**

- 树中的节点数在 `[1, 100]` 范围内。
- `0 <= Node.val <= 100`
- 树中的所有值均 **不重复** 。



### 思路

右根左遍历

val 变成在该结点之前访问的 累加值

```c++
class Solution {
public:
    int sum = 0;
    int dfs(TreeNode* root) {
        if(!root) return 0;
        int r = dfs(root->right);
        int val = root->val;
        // 遍历右边的值就修改他的值
        sum += val;
        root->val = sum;
        int l = dfs(root->left);
        
        return r + val + l;
    }
    TreeNode* bstToGst(TreeNode* root) {
   
        dfs(root);
        return root;
    }
};
```



## [1833. 雪糕的最大数量](https://leetcode.cn/problems/maximum-ice-cream-bars/)

==模拟== ==2023年12月5日==

夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。

商店中新到 `n` 支雪糕，用长度为 `n` 的数组 `costs` 表示雪糕的定价，其中 `costs[i]` 表示第 `i` 支雪糕的现金价格。Tony 一共有 `coins` 现金可以用于消费，他想要买尽可能多的雪糕。

**注意：**Tony 可以按任意顺序购买雪糕。

给你价格数组 `costs` 和现金量 `coins` ，请你计算并返回 Tony 用 `coins` 现金能够买到的雪糕的 **最大数量** 。

你必须使用计数排序解决此问题。

 

**示例 1：**

```bash
输入：costs = [1,3,2,4,1], coins = 7
输出：4
解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7
```



### 思路

每次选最便宜的买就行了，这样使得剩下钱更多，才可能买更多数量的东西

```c++
class Solution {
public:
    int maxIceCream(vector<int>& costs, int coins) {
        sort(costs.begin(),costs.end());
        int res = 0;
        for(auto c: costs) {
            if(c <= coins) res += 1, coins -= c;
        }
        return res;
    }
};
```



## [241. 为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/)

==分治== ==2023年12月6日== 

给你一个由数字和运算符组成的字符串 `expression` ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 **按任意顺序** 返回答案。

生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 `104` 。

 

**示例 1：**

```bash
输入：expression = "2-1-1"
输出：[0,2]
解释：
((2-1)-1) = 0 
(2-(1-1)) = 2
```



**提示：**

- `1 <= expression.length <= 20`
- `expression` 由数字和算符 `'+'`、`'-'` 和 `'*'` 组成。
- 输入表达式中的所有整数值在范围 `[0, 99]` 



### 思路

不用判断 运算符 的优先级，所以选择 运算符的计算顺序即可

递归出口：纯数字

```c++
class Solution {
public:
    string s;
    vector<int> dfs(int l,int r) {
        vector<int> res;
        for(int i = l; i <= r; i ++) {
            if(s[i] >= '0' && s[i] <= '9') continue;
            // 此时 s[i] 是 运算符
            // 拿到左边的运算结果，右边的运算结果
            // 左边：也是有不同的运算顺序，带来不同的结果
            auto left = dfs(l,i-1), right = dfs(i+1,r);
            for(int a: left) {
                for(int b: right) {
                    int cur = 0;
                    if(s[i] == '+') cur = a + b;
                    else if(s[i] == '-') cur = a - b;
                    else cur = a * b;
                    res.push_back(cur);
                }
            }
        }
        // 递归出口：纯数字
        if(res.empty()) {
            int cur = 0;
            for(int i = l; i <= r; i ++) cur = cur * 10 + s[i] - '0';
            res.push_back(cur);
        }
        return res;
    }
    vector<int> diffWaysToCompute(string expression) {
        
        s = expression;
        return dfs(0,s.size() - 1);
    }
};
```

