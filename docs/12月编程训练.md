

## [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

==双指针==，==2023年12月1日== 



给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：**你不能倾斜容器。

**提示：**

- `n == height.length`
- `2 <= n <= 105`
- `0 <= height[i] <= 104`



**示例一** 

![img](https://gcore.jsdelivr.net/gh/lzcgeorge/imagebed@main/question_11.jpg)

```bash
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

### 思路

在每个状态下，无论长板或短板向中间收窄一格，都会导致水槽 **底边宽度** $−1$ 变短：

- 若向内 移动短板 ，水槽的短板 $min(h[i],h[j])$ 可能变大，因此下个水槽的面积 可能增大 。
- 若向内 移动长板 ，水槽的短板 $min(h[i],h[j])$ 不变或变小，因此下个水槽的面积 一定变小 。

因此，初始化双指针分列水槽左右两端，循环每轮将短板向内移动一格，并更新面积最大值，直到两指针相遇时跳出；即可获得最大面积。

```c++
class Solution {
public:
    int maxArea(vector<int>& h) {
        int l = 0,r = h.size() - 1;
        int mx = (r - l) * min(h[l],h[r]);

        while(l < r) {
            if(h[l] < h[r]) 
                l ++;
            else r --;
            mx = max(mx,(r - l) * min(h[l],h[r]));
        }
        return mx;
    }
};
```

## [2661. 找出叠涂元素](https://leetcode.cn/problems/first-completely-painted-row-or-column/)

==hash== ==2023年12月1日==

给你一个下标从 **0** 开始的整数数组 `arr` 和一个 `m x n` 的整数 **矩阵** `mat` 。`arr` 和 `mat` 都包含范围 `[1，m * n]` 内的 **所有** 整数。

从下标 `0` 开始遍历 `arr` 中的每个下标 `i` ，并将包含整数 `arr[i]` 的 `mat` 单元格涂色。

请你找出 `arr` 中在 `mat` 的某一行或某一列上都被涂色且下标最小的元素，并返回其下标 `i` 。



**示例 1：**

![image explanation for example 1](https://gcore.jsdelivr.net/gh/lzcgeorge/imagebed@main/grid1.jpg)

```bash
输入：arr = [1,3,4,2], mat = [[1,4],[2,3]]
输出：2
解释：遍历如上图所示，arr[2] 在矩阵中的第一行或第二列上都被涂色。
```

### 思路

​    1. 记录 `mat` 矩阵中每一个数的行和列

​    2. 扫描 `arr` 数组，每进来一个数，当前的行和列分别加一

​    3. 当前行/列 满的时候退出

​    4. 时间复杂度：$O(n*m) + O(n*m) = O(n*m)$

 ```c++
 class Solution {
 public:
     int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {
         map<int,pair<int,int>> mp;
         int n = mat.size(), m = mat[0].size();
         vector<int> row(n,0),col(m,0);
         for(int i = 0; i < n; i ++)
             for(int j = 0; j < m; j ++) {
                 mp[mat[i][j]] = {i,j};
             }
         
         for(int i = 0; i < n*m; i ++) {
             auto [x,y] = mp[arr[i]];
             row[x] ++, col[y] ++;
             // 注意：某一行有多少个数 = 列的个数
             if(row[x] == m || col[y] == n) {
                 return i;
             }
         }
 
         return -1; // 实际走不到这里
     }
 };
 ```

## [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

==模拟== ==2023年12月2日==

给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。

请 **不要使用除法，**且在 `O(n)` 时间复杂度内完成此题。

**示例 1:**

```bash
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**提示：**

- `2 <= nums.length <= 105`
- `-30 <= nums[i] <= 30`
- **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内



### 思路

```bash
/*
原数组：       [1       2       3       4]
左部分的乘积：   1       1      1*2    1*2*3
右部分的乘积： 2*3*4    3*4      4      1
结果：        1*2*3*4  1*3*4   1*2*4  1*2*3*1

*/
```



```c++

class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> left(n,1),right(n,1);
        // 前缀
        for(int i = 1; i < n; i ++)
            left[i] = nums[i - 1] * left[i - 1];
        // 后缀
        for(int j = n-2; j >= 0; j -- )
            right[j] = nums[j + 1] * right[j + 1];
        // 合并 
        for(int i = 0; i < n; i ++)
            right[i] = left[i] * right[i];
        return right;
            
    }
};
```

## [1094. 拼车](https://leetcode.cn/problems/car-pooling/)

==差分数组== ==2023年12月2日==

车上最初有 `capacity` 个空座位。车 **只能** 向一个方向行驶（也就是说，**不允许掉头或改变方向**）

给定整数 `capacity` 和一个数组 `trips` ,  `trip[i] = [numPassengersi, fromi, toi]` 表示第 `i` 次旅行有 `numPassengersi` 乘客，接他们和放他们的位置分别是 `fromi` 和 `toi` 。这些位置是从汽车的初始位置向东的公里数。

当且仅当你可以在所有给定的行程中接送所有乘客时，返回 `true`，否则请返回 `false`。



**示例 1：**

```bash
输入：trips = [[2,1,5],[3,3,7]], capacity = 4
输出：false
```



**提示：**

- `1 <= trips.length <= 1000`
- `trips[i].length == 3`
- `1 <= numPassengersi <= 100`
- `0 <= fromi < toi <= 1000`
- `1 <= capacity <= 105`



### 思路

1. 保证，每一站上都是 people  < capacity
2. 处理差分数组，然后还原数组，某个点上的最大人数
3. 一些细节：为了方便，人为规定站点编号从 1 开始。

```c++
class Solution {
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        // 其实用不到排序
        /*
            auto cmp = [](auto a,auto b) {
                if(a[1] == b[1] ) return a[2] < b[2];
                return a[1] < b[1];
            };
            sort(trips.begin(),trips.end(),cmp);
		*/
        
        int n = trips.size();
        vector<int> peo(1002,0);
        for(auto c: trips) {
            int from = c[1],to = c[2];
            int num = c[0];
            peo[from + 1] += num;
            peo[to + 1] -= num;
        }
        for(int i = 1; i <= 1001; i ++) {
            peo[i] += peo[i-1];
            if(peo[i] > capacity) return false;
        }
        return true;
    }
};
```



## [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

==模拟== ==滑动窗口== ==2023年12月2日== 

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。



**示例 1：**

```bash
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```



**提示：**

- `1 <= target <= 109`
- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 105`

 

### 思路

第一版代码:

先判断是否有解

有解的话，先找出一个满足条件的解，然后 滑动窗口 （开滑！）

```c++
using ll = long long;
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        ll sum = 0;
        for(auto c: nums) sum += c;
        if(sum < target) return 0;
        ll t = 0;
        int l = 0,r = 0;
        while(t + nums[r] < target) t += nums[r ++];
        int res = r - l + 1;
        while(r < nums.size()) {
            // cout << l << " " << r <<"\n";
            t += nums[r++];
            while(t >= target) t -= nums[l ++];
            res = min(res, r - l + 1);
        }        
        return res;
    }
};
```



第二版代码：

直接滑，满足条件的记录值

```c++
using ll = long long;
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        ll sum = 0;
        int l = 0,r = 0, res = nums.size() + 1;
        while(r < nums.size()) {
            sum += nums[r++];
            while(sum >= target) {
                sum -= nums[l ++];
                res = min(res, r - l + 1);
            }
            
        }        
        return res > nums.size() ? 0 : res;
    }
};
```

## [1423. 可获得的最大点数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/)

==模拟== ==滑动窗口== ==2023年12月3日== 

几张卡牌 **排成一行**，每张卡牌都有一个对应的点数。点数由整数数组 `cardPoints` 给出。

每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 `k` 张卡牌。

你的点数就是你拿到手中的所有卡牌的点数之和。

给你一个整数数组 `cardPoints` 和整数 `k`，请你返回可以获得的最大点数。

 

**示例 1：**

```bash
输入：cardPoints = [1,2,3,4,5,6,1], k = 3
输出：12
解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。
```



**提示：**

- `1 <= cardPoints.length <= 10^5`
- `1 <= cardPoints[i] <= 10^4`
- `1 <= k <= cardPoints.length`



### 思路

1. 最后的结果：前面 a 个，后面 b 个，a + b = k
2. 前假设都在前面选，得到一个 `cur` 结果
3. 然后逐次递减在前面选的，从后面选



```c++
class Solution {
public:
    int maxScore(vector<int>& a, int k) {
        // 最后的结果：前面 a 个，后面 b 个，a + b = k
        int n = a.size();
        int mx = -1,cur = 0;
        for(int i = 0; i < k; i ++) cur += a[i];
        mx = cur;

        // 滑动窗口
        for(int l = k-1,r = n - 1; l >= 0; l --,r --) {
            cur = cur - a[l] + a[r];
            mx = max(mx,cur);
        }
        return mx;
    }
};
```

